<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LydiaSyft: Syft::VarMgr Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LydiaSyft
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classSyft_1_1VarMgr.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSyft_1_1VarMgr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Syft::VarMgr Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A dictionary that maps variable names to indices and vice versa.  
 <a href="classSyft_1_1VarMgr.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="VarMgr_8h_source.html">VarMgr.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1b5b1ace9b0157d1087bff239260cd65"><td class="memItemLeft" align="right" valign="top"><a id="a1b5b1ace9b0157d1087bff239260cd65"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSyft_1_1VarMgr.html#a1b5b1ace9b0157d1087bff239260cd65">VarMgr</a> ()</td></tr>
<tr class="memdesc:a1b5b1ace9b0157d1087bff239260cd65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classSyft_1_1VarMgr.html" title="A dictionary that maps variable names to indices and vice versa.">VarMgr</a> with no variables. <br /></td></tr>
<tr class="separator:a1b5b1ace9b0157d1087bff239260cd65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624e50cbd328e79847949a02c5450c9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSyft_1_1VarMgr.html#a624e50cbd328e79847949a02c5450c9a">create_named_variables</a> (const std::vector&lt; std::string &gt; &amp;variable_names)</td></tr>
<tr class="memdesc:a624e50cbd328e79847949a02c5450c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates BDD variables and associates each with a name.  <a href="classSyft_1_1VarMgr.html#a624e50cbd328e79847949a02c5450c9a">More...</a><br /></td></tr>
<tr class="separator:a624e50cbd328e79847949a02c5450c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae532b674990f328df75803861fc83019"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSyft_1_1VarMgr.html#ae532b674990f328df75803861fc83019">create_state_variables</a> (std::size_t variable_count)</td></tr>
<tr class="memdesc:ae532b674990f328df75803861fc83019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and stores state variables.  <a href="classSyft_1_1VarMgr.html#ae532b674990f328df75803861fc83019">More...</a><br /></td></tr>
<tr class="separator:ae532b674990f328df75803861fc83019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4600a6e9ef8a146d30134d7c15f885"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSyft_1_1VarMgr.html#ada4600a6e9ef8a146d30134d7c15f885">create_product_state_space</a> (const std::vector&lt; std::size_t &gt; &amp;automaton_ids)</td></tr>
<tr class="memdesc:ada4600a6e9ef8a146d30134d7c15f885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a new automaton ID associated with a product state space.  <a href="classSyft_1_1VarMgr.html#ada4600a6e9ef8a146d30134d7c15f885">More...</a><br /></td></tr>
<tr class="separator:ada4600a6e9ef8a146d30134d7c15f885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4585a150e1a0bc2d908d0e249f95ea9a"><td class="memItemLeft" align="right" valign="top"><a id="a4585a150e1a0bc2d908d0e249f95ea9a"></a>
CUDD::BDD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSyft_1_1VarMgr.html#a4585a150e1a0bc2d908d0e249f95ea9a">state_variable</a> (std::size_t automaton_id, std::size_t i) const</td></tr>
<tr class="memdesc:a4585a150e1a0bc2d908d0e249f95ea9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the i-th state variable for a given automaton. <br /></td></tr>
<tr class="separator:a4585a150e1a0bc2d908d0e249f95ea9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd8b52db7087b049cc588e4ebbe9b20"><td class="memItemLeft" align="right" valign="top">CUDD::BDD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSyft_1_1VarMgr.html#a8cd8b52db7087b049cc588e4ebbe9b20">state_vector_to_bdd</a> (std::size_t automaton_id, const std::vector&lt; int &gt; &amp;state_vector) const</td></tr>
<tr class="memdesc:a8cd8b52db7087b049cc588e4ebbe9b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a state vector to a BDD.  <a href="classSyft_1_1VarMgr.html#a8cd8b52db7087b049cc588e4ebbe9b20">More...</a><br /></td></tr>
<tr class="separator:a8cd8b52db7087b049cc588e4ebbe9b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab829aa3b49133ac514a30cbd060eb117"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSyft_1_1VarMgr.html#ab829aa3b49133ac514a30cbd060eb117">partition_variables</a> (const std::vector&lt; std::string &gt; &amp;input_names, const std::vector&lt; std::string &gt; &amp;output_names)</td></tr>
<tr class="memdesc:ab829aa3b49133ac514a30cbd060eb117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitions the named variables between inputs and outputs.  <a href="classSyft_1_1VarMgr.html#ab829aa3b49133ac514a30cbd060eb117">More...</a><br /></td></tr>
<tr class="separator:ab829aa3b49133ac514a30cbd060eb117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cca5b6b5c8ac7653162a84a0314204d"><td class="memItemLeft" align="right" valign="top"><a id="a2cca5b6b5c8ac7653162a84a0314204d"></a>
std::shared_ptr&lt; CUDD::Cudd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSyft_1_1VarMgr.html#a2cca5b6b5c8ac7653162a84a0314204d">cudd_mgr</a> () const</td></tr>
<tr class="memdesc:a2cca5b6b5c8ac7653162a84a0314204d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the CUDD manager used to create the variables. <br /></td></tr>
<tr class="separator:a2cca5b6b5c8ac7653162a84a0314204d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3e6a63ab9e482caf2a0e38a0493e6c"><td class="memItemLeft" align="right" valign="top"><a id="a2e3e6a63ab9e482caf2a0e38a0493e6c"></a>
CUDD::BDD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSyft_1_1VarMgr.html#a2e3e6a63ab9e482caf2a0e38a0493e6c">name_to_variable</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a2e3e6a63ab9e482caf2a0e38a0493e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the variable with the given name. <br /></td></tr>
<tr class="separator:a2e3e6a63ab9e482caf2a0e38a0493e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c5cc79c94f17c76de11399933dd045"><td class="memItemLeft" align="right" valign="top"><a id="a11c5cc79c94f17c76de11399933dd045"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSyft_1_1VarMgr.html#a11c5cc79c94f17c76de11399933dd045">index_to_name</a> (int index) const</td></tr>
<tr class="memdesc:a11c5cc79c94f17c76de11399933dd045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the variable at index <em>index</em>. <br /></td></tr>
<tr class="separator:a11c5cc79c94f17c76de11399933dd045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c39857542ccbecd14aaa1c6e8d5551"><td class="memItemLeft" align="right" valign="top"><a id="ae8c39857542ccbecd14aaa1c6e8d5551"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSyft_1_1VarMgr.html#ae8c39857542ccbecd14aaa1c6e8d5551">total_variable_count</a> () const</td></tr>
<tr class="memdesc:ae8c39857542ccbecd14aaa1c6e8d5551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of variables, including named and state. <br /></td></tr>
<tr class="separator:ae8c39857542ccbecd14aaa1c6e8d5551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387816710b48e0131d72e929bdc8e0ae"><td class="memItemLeft" align="right" valign="top"><a id="a387816710b48e0131d72e929bdc8e0ae"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSyft_1_1VarMgr.html#a387816710b48e0131d72e929bdc8e0ae">total_state_variable_count</a> () const</td></tr>
<tr class="memdesc:a387816710b48e0131d72e929bdc8e0ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of state variables. <br /></td></tr>
<tr class="separator:a387816710b48e0131d72e929bdc8e0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c878bdf9e9cc1d718a67f4e1955bf9"><td class="memItemLeft" align="right" valign="top"><a id="ad3c878bdf9e9cc1d718a67f4e1955bf9"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSyft_1_1VarMgr.html#ad3c878bdf9e9cc1d718a67f4e1955bf9">state_variable_count</a> (std::size_t automaton_id) const</td></tr>
<tr class="memdesc:ad3c878bdf9e9cc1d718a67f4e1955bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of state variables for a given automaton. <br /></td></tr>
<tr class="separator:ad3c878bdf9e9cc1d718a67f4e1955bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1fa46a7b9911d683bb18b2acbb1d69"><td class="memItemLeft" align="right" valign="top"><a id="abe1fa46a7b9911d683bb18b2acbb1d69"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSyft_1_1VarMgr.html#abe1fa46a7b9911d683bb18b2acbb1d69">input_variable_count</a> () const</td></tr>
<tr class="memdesc:abe1fa46a7b9911d683bb18b2acbb1d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of input variables. <br /></td></tr>
<tr class="separator:abe1fa46a7b9911d683bb18b2acbb1d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac175ed202b133e0dace9362b22f3ac57"><td class="memItemLeft" align="right" valign="top"><a id="ac175ed202b133e0dace9362b22f3ac57"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSyft_1_1VarMgr.html#ac175ed202b133e0dace9362b22f3ac57">output_variable_count</a> () const</td></tr>
<tr class="memdesc:ac175ed202b133e0dace9362b22f3ac57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of output variables. <br /></td></tr>
<tr class="separator:ac175ed202b133e0dace9362b22f3ac57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d61504ecc6df26d61e0e50dea0b5706"><td class="memItemLeft" align="right" valign="top"><a id="a1d61504ecc6df26d61e0e50dea0b5706"></a>
CUDD::BDD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSyft_1_1VarMgr.html#a1d61504ecc6df26d61e0e50dea0b5706">input_cube</a> () const</td></tr>
<tr class="memdesc:a1d61504ecc6df26d61e0e50dea0b5706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a BDD formed by the conjunction of all input variables. <br /></td></tr>
<tr class="separator:a1d61504ecc6df26d61e0e50dea0b5706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae667a77bc43e813b027205620d475f"><td class="memItemLeft" align="right" valign="top"><a id="abae667a77bc43e813b027205620d475f"></a>
CUDD::BDD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSyft_1_1VarMgr.html#abae667a77bc43e813b027205620d475f">output_cube</a> () const</td></tr>
<tr class="memdesc:abae667a77bc43e813b027205620d475f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a BDD formed by the conjunction of all output variables. <br /></td></tr>
<tr class="separator:abae667a77bc43e813b027205620d475f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe31cc2babdf454ef853f6480b53192f"><td class="memItemLeft" align="right" valign="top"><a id="afe31cc2babdf454ef853f6480b53192f"></a>
CUDD::BDD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSyft_1_1VarMgr.html#afe31cc2babdf454ef853f6480b53192f">state_variables_cube</a> (std::size_t automaton_id) const</td></tr>
<tr class="memdesc:afe31cc2babdf454ef853f6480b53192f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a BDD formed by the conjunction of all state variables of automaton automaton_id. <br /></td></tr>
<tr class="separator:afe31cc2babdf454ef853f6480b53192f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af210f7054001c41a021a4848a27e4a14"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSyft_1_1VarMgr.html#af210f7054001c41a021a4848a27e4a14">make_eval_vector</a> (std::size_t automaton_id, const std::vector&lt; int &gt; &amp;state_vector) const</td></tr>
<tr class="memdesc:af210f7054001c41a021a4848a27e4a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a valid input to CUDD::BDD::Eval.  <a href="classSyft_1_1VarMgr.html#af210f7054001c41a021a4848a27e4a14">More...</a><br /></td></tr>
<tr class="separator:af210f7054001c41a021a4848a27e4a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02dea41f6c9bc9f60991c4538e0117cf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSyft_1_1VarMgr.html#a02dea41f6c9bc9f60991c4538e0117cf">make_state_eval_vector</a> (std::size_t automaton_id, const std::vector&lt; int &gt; &amp;state_vector) const</td></tr>
<tr class="memdesc:a02dea41f6c9bc9f60991c4538e0117cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a valid input to CUDD::BDD::Eval.  <a href="classSyft_1_1VarMgr.html#a02dea41f6c9bc9f60991c4538e0117cf">More...</a><br /></td></tr>
<tr class="separator:a02dea41f6c9bc9f60991c4538e0117cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5fc355872038ae5564da7d436709eb7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; CUDD::BDD &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSyft_1_1VarMgr.html#af5fc355872038ae5564da7d436709eb7">make_compose_vector</a> (std::size_t automaton_id, const std::vector&lt; CUDD::BDD &gt; &amp;state_bdds) const</td></tr>
<tr class="memdesc:af5fc355872038ae5564da7d436709eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a valid input to CUDD::BDD::VectorCompose.  <a href="classSyft_1_1VarMgr.html#af5fc355872038ae5564da7d436709eb7">More...</a><br /></td></tr>
<tr class="separator:af5fc355872038ae5564da7d436709eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef5b1b9131a252617ffafc2f5021be1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSyft_1_1VarMgr.html#afef5b1b9131a252617ffafc2f5021be1">variable_labels</a> () const</td></tr>
<tr class="memdesc:afef5b1b9131a252617ffafc2f5021be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with a label for each variable.  <a href="classSyft_1_1VarMgr.html#afef5b1b9131a252617ffafc2f5021be1">More...</a><br /></td></tr>
<tr class="separator:afef5b1b9131a252617ffafc2f5021be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d23f98e3716b1f8f1528c7a0e82a199"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSyft_1_1VarMgr.html#a3d23f98e3716b1f8f1528c7a0e82a199">input_variable_labels</a> () const</td></tr>
<tr class="memdesc:a3d23f98e3716b1f8f1528c7a0e82a199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with a label for each input variable.  <a href="classSyft_1_1VarMgr.html#a3d23f98e3716b1f8f1528c7a0e82a199">More...</a><br /></td></tr>
<tr class="separator:a3d23f98e3716b1f8f1528c7a0e82a199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abb49c5f62b69c00975d2e810c8e99a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSyft_1_1VarMgr.html#a1abb49c5f62b69c00975d2e810c8e99a">output_variable_labels</a> () const</td></tr>
<tr class="memdesc:a1abb49c5f62b69c00975d2e810c8e99a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with a label for each output variable.  <a href="classSyft_1_1VarMgr.html#a1abb49c5f62b69c00975d2e810c8e99a">More...</a><br /></td></tr>
<tr class="separator:a1abb49c5f62b69c00975d2e810c8e99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b969a46c6e16f4489c1b3cdd3ad1b2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSyft_1_1VarMgr.html#a71b969a46c6e16f4489c1b3cdd3ad1b2">state_variable_labels</a> (std::size_t automaton_id) const</td></tr>
<tr class="memdesc:a71b969a46c6e16f4489c1b3cdd3ad1b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with a label for each state variable.  <a href="classSyft_1_1VarMgr.html#a71b969a46c6e16f4489c1b3cdd3ad1b2">More...</a><br /></td></tr>
<tr class="separator:a71b969a46c6e16f4489c1b3cdd3ad1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d03ecaca62d7a1eeaaf5a28bd73d6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSyft_1_1VarMgr.html#ab8d03ecaca62d7a1eeaaf5a28bd73d6c">dump_dot</a> (const CUDD::ADD &amp;add, const std::string &amp;filename) const</td></tr>
<tr class="memdesc:ab8d03ecaca62d7a1eeaaf5a28bd73d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves an ADD in a .dot file.  <a href="classSyft_1_1VarMgr.html#ab8d03ecaca62d7a1eeaaf5a28bd73d6c">More...</a><br /></td></tr>
<tr class="separator:ab8d03ecaca62d7a1eeaaf5a28bd73d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293ad8c34f959aaeea0fa38aa2bca50d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSyft_1_1VarMgr.html#a293ad8c34f959aaeea0fa38aa2bca50d">dump_dot</a> (const std::vector&lt; CUDD::ADD &gt; &amp;adds, const std::vector&lt; std::string &gt; &amp;function_labels, const std::string &amp;filename) const</td></tr>
<tr class="memdesc:a293ad8c34f959aaeea0fa38aa2bca50d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves ADDs to a .dot file with corresponding labels.  <a href="classSyft_1_1VarMgr.html#a293ad8c34f959aaeea0fa38aa2bca50d">More...</a><br /></td></tr>
<tr class="separator:a293ad8c34f959aaeea0fa38aa2bca50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1562901363bb109776a991853e114e89"><td class="memItemLeft" align="right" valign="top"><a id="a1562901363bb109776a991853e114e89"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSyft_1_1VarMgr.html#a1562901363bb109776a991853e114e89">automaton_num</a> () const</td></tr>
<tr class="memdesc:a1562901363bb109776a991853e114e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of DFAs the manager handles. <br /></td></tr>
<tr class="separator:a1562901363bb109776a991853e114e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80bcad06ff814173f8fa58f4e337acb3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSyft_1_1VarMgr.html#a80bcad06ff814173f8fa58f4e337acb3">bdd_to_string</a> (const CUDD::BDD &amp;bdd) const</td></tr>
<tr class="memdesc:a80bcad06ff814173f8fa58f4e337acb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a BDD as a Boolean formula, where each variable has a specific label.  <a href="classSyft_1_1VarMgr.html#a80bcad06ff814173f8fa58f4e337acb3">More...</a><br /></td></tr>
<tr class="separator:a80bcad06ff814173f8fa58f4e337acb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20968a4054e4474addf55e6857d0bcff"><td class="memItemLeft" align="right" valign="top"><a id="a20968a4054e4474addf55e6857d0bcff"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSyft_1_1VarMgr.html#a20968a4054e4474addf55e6857d0bcff">create_complement_state_space</a> (const std::size_t automaton_id)</td></tr>
<tr class="memdesc:a20968a4054e4474addf55e6857d0bcff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the state space when complementing a DFA. <br /></td></tr>
<tr class="separator:a20968a4054e4474addf55e6857d0bcff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A dictionary that maps variable names to indices and vice versa. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a80bcad06ff814173f8fa58f4e337acb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80bcad06ff814173f8fa58f4e337acb3">&#9670;&nbsp;</a></span>bdd_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Syft::VarMgr::bdd_to_string </td>
          <td>(</td>
          <td class="paramtype">const CUDD::BDD &amp;&#160;</td>
          <td class="paramname"><em>bdd</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a BDD as a Boolean formula, where each variable has a specific label. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>given BDD. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string that represents a Boolean formula. </dd></dl>

</div>
</div>
<a id="a624e50cbd328e79847949a02c5450c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624e50cbd328e79847949a02c5450c9a">&#9670;&nbsp;</a></span>create_named_variables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Syft::VarMgr::create_named_variables </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>variable_names</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates BDD variables and associates each with a name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variable_names</td><td>The names of the variables to create. A new variable is only created if a variable by that name does not already exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada4600a6e9ef8a146d30134d7c15f885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada4600a6e9ef8a146d30134d7c15f885">&#9670;&nbsp;</a></span>create_product_state_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Syft::VarMgr::create_product_state_space </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>automaton_ids</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a new automaton ID associated with a product state space. </p>
<p>This function does not create new state variables. Instead, the variables associated with the new ID are the union of all variables for the automata that form the product.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">automaton_ids</td><td>A vector of automaton IDs all of which must already exist in the manager. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The automaton ID for the automaton formed by taking the product of the automata whose IDs were provided in <em>automaton_ids</em>. </dd></dl>

</div>
</div>
<a id="ae532b674990f328df75803861fc83019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae532b674990f328df75803861fc83019">&#9670;&nbsp;</a></span>create_state_variables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Syft::VarMgr::create_state_variables </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>variable_count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and stores state variables. </p>
<p>Multiple calls of this function create separate groups of state variables. The call generates an ID for the automaton whose state space the variables represent, so that the correct group of variables can be retrieved later.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variable_count</td><td>The number of state variables to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The automaton ID the variables are associated with. </dd></dl>

</div>
</div>
<a id="ab8d03ecaca62d7a1eeaaf5a28bd73d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d03ecaca62d7a1eeaaf5a28bd73d6c">&#9670;&nbsp;</a></span>dump_dot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Syft::VarMgr::dump_dot </td>
          <td>(</td>
          <td class="paramtype">const CUDD::ADD &amp;&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves an ADD in a .dot file. </p>
<p>Uses ADD for better visualization in the .dot file. To call with a BDD, use <em>dump_dot</em>(bdd.Add(), filename).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">An</td><td>ADD <em>add</em> and <em>filename</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a293ad8c34f959aaeea0fa38aa2bca50d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a293ad8c34f959aaeea0fa38aa2bca50d">&#9670;&nbsp;</a></span>dump_dot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Syft::VarMgr::dump_dot </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; CUDD::ADD &gt; &amp;&#160;</td>
          <td class="paramname"><em>adds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>function_labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves ADDs to a .dot file with corresponding labels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adds</td><td>A vector of ADDs to be saved to file. </td></tr>
    <tr><td class="paramname">function_labels</td><td>A vector such that <em>function_labels</em>[i] contains the label for <em>adds</em>[i]. The labels appear above the corresponding ADD in the file. </td></tr>
    <tr><td class="paramname">filename</td><td>The name of the .dot file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d23f98e3716b1f8f1528c7a0e82a199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d23f98e3716b1f8f1528c7a0e82a199">&#9670;&nbsp;</a></span>input_variable_labels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Syft::VarMgr::input_variable_labels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector with a label for each input variable. </p>
<p>To be used with CUDD::Cudd::DumpDot.</p>
<dl class="section return"><dt>Returns</dt><dd>A vector <em>v</em> such that <em>v</em>[i] contains the name of the i-th input variable. </dd></dl>

</div>
</div>
<a id="af5fc355872038ae5564da7d436709eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5fc355872038ae5564da7d436709eb7">&#9670;&nbsp;</a></span>make_compose_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; CUDD::BDD &gt; Syft::VarMgr::make_compose_vector </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>automaton_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; CUDD::BDD &gt; &amp;&#160;</td>
          <td class="paramname"><em>state_bdds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a valid input to CUDD::BDD::VectorCompose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">automaton_id</td><td>The ID of the automaton whose variables to use. </td></tr>
    <tr><td class="paramname">state_bdds</td><td>A vector containing one BDD for each state variable of the automaton. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with one position for each BDD variable, including both named and state variables, where the index corresponding to the i-th state variable of the requested automaton contains <em>state_bdds</em>[i]. Indices corresponding to other variables have the identity BDD for that variable. </dd></dl>

</div>
</div>
<a id="af210f7054001c41a021a4848a27e4a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af210f7054001c41a021a4848a27e4a14">&#9670;&nbsp;</a></span>make_eval_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; Syft::VarMgr::make_eval_vector </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>automaton_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>state_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a valid input to CUDD::BDD::Eval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">automaton_id</td><td>The ID of the automaton whose variables to use. </td></tr>
    <tr><td class="paramname">state_vector</td><td>A vector of 1s and 0s encoding a state's binary representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with one position for each BDD variable, including both named and state variables, where the index corresponding to the i-th state variable of the requested automaton contains <em>state_vector</em>[i]. Indices corresponding to other variables have a 0. </dd></dl>

</div>
</div>
<a id="a02dea41f6c9bc9f60991c4538e0117cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02dea41f6c9bc9f60991c4538e0117cf">&#9670;&nbsp;</a></span>make_state_eval_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; Syft::VarMgr::make_state_eval_vector </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>automaton_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>state_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a valid input to CUDD::BDD::Eval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">automaton_id</td><td>The ID of the automaton whose variables to use. </td></tr>
    <tr><td class="paramname">state_vector</td><td>A vector of 1s and 0s encoding a state's binary representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with one position for each BDD variable, including only state variables, where the index corresponding to the i-th state variable of the requested automaton contains <em>state_vector</em>[i]. Indices corresponding to other variables have a 0. </dd></dl>

</div>
</div>
<a id="a1abb49c5f62b69c00975d2e810c8e99a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1abb49c5f62b69c00975d2e810c8e99a">&#9670;&nbsp;</a></span>output_variable_labels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Syft::VarMgr::output_variable_labels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector with a label for each output variable. </p>
<p>To be used with CUDD::Cudd::DumpDot.</p>
<dl class="section return"><dt>Returns</dt><dd>A vector <em>v</em> such that <em>v</em>[i] contains the name of the i-th output variable. </dd></dl>

</div>
</div>
<a id="ab829aa3b49133ac514a30cbd060eb117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab829aa3b49133ac514a30cbd060eb117">&#9670;&nbsp;</a></span>partition_variables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Syft::VarMgr::partition_variables </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partitions the named variables between inputs and outputs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_names</td><td>The names of the variables that should be considered inputs. </td></tr>
    <tr><td class="paramname">output_names</td><td>The names of the variables that should be considered outputs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71b969a46c6e16f4489c1b3cdd3ad1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b969a46c6e16f4489c1b3cdd3ad1b2">&#9670;&nbsp;</a></span>state_variable_labels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Syft::VarMgr::state_variable_labels </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>automaton_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector with a label for each state variable. </p>
<p>To be used with CUDD::Cudd::DumpDot.</p>
<dl class="section return"><dt>Returns</dt><dd>A vector <em>v</em> such that <em>v</em>[i] has a label for the i-th state variable. The label is the same as the one used in <em><a class="el" href="classSyft_1_1VarMgr.html#afef5b1b9131a252617ffafc2f5021be1" title="Returns a vector with a label for each variable.">variable_labels()</a></em>. </dd></dl>

</div>
</div>
<a id="a8cd8b52db7087b049cc588e4ebbe9b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cd8b52db7087b049cc588e4ebbe9b20">&#9670;&nbsp;</a></span>state_vector_to_bdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDD::BDD Syft::VarMgr::state_vector_to_bdd </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>automaton_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>state_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a state vector to a BDD. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">automaton_id</td><td>The ID of the automaton whose variables to use. </td></tr>
    <tr><td class="paramname">state_vector</td><td>A vector of 1s and 0s encoding a state's binary representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A BDD representing a conjunction (l_1 &amp; l_2 &amp; ... &amp; l_n) where l_i = !x_i if <em>state_vector</em>[i] = 0 and l_i = x_i otherwise, where x_i is the i-th state variable of the automaton with the given ID. </dd></dl>

</div>
</div>
<a id="afef5b1b9131a252617ffafc2f5021be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef5b1b9131a252617ffafc2f5021be1">&#9670;&nbsp;</a></span>variable_labels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Syft::VarMgr::variable_labels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector with a label for each variable. </p>
<p>To be used with CUDD::Cudd::DumpDot.</p>
<dl class="section return"><dt>Returns</dt><dd>A vector <em>v</em> such that <em>v</em>[i] has a label for the variable with index <em>i</em>. For named variables the label is the variable's name. For state variables the label is a representation that indicates which automaton the variable is from and which bit of the state it represents. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/synthesis/header/<a class="el" href="VarMgr_8h_source.html">VarMgr.h</a></li>
<li>src/synthesis/source/VarMgr.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>Syft</b></li><li class="navelem"><a class="el" href="classSyft_1_1VarMgr.html">VarMgr</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
