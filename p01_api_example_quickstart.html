<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LydiaSyft: Quickstart</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LydiaSyft
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('p01_api_example_quickstart.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Quickstart </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_docs_api_p01_api_example_quickstart"></a> LydiaSyft can be used as a C++ library that integrates with other project. In this page we will walk through each example and explain the main features supported by the library. The examples can be found in the <code>examples/</code> folder.</p>
<p>In this example, we will see how to use the LydiaSyft C++ APIs to solve an instance of the LTLf synthesis problem in the classical setting. <br  />
 The code for this example can be found in <code>examples/01_quickstart/quickstart.cpp</code>. To build this example, you can run <code>make quickstart_example</code>.</p>
<p>The content of the file <code>quickstart.cpp</code> is:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;lydia/parser/ltlf/driver.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;automata/ExplicitStateDfa.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;automata/ExplicitStateDfaAdd.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;automata/SymbolicStateDfa.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;game/InputOutputPartition.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Player.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;VarMgr.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;synthesizer/LTLfSynthesizer.h&quot;</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> ** argv) {</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// define the formula and the input/output variables</span></div>
<div class="line">    std::string formula_str = <span class="stringliteral">&quot;F(a | b)&quot;</span>;</div>
<div class="line">    std::vector&lt;std::string&gt; input_vars{<span class="stringliteral">&quot;a&quot;</span>};</div>
<div class="line">    std::vector&lt;std::string&gt; output_vars{<span class="stringliteral">&quot;b&quot;</span>};</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// parse the formula</span></div>
<div class="line">    <span class="keyword">auto</span> driver = std::make_shared&lt;whitemech::lydia::parsers::ltlf::LTLfDriver&gt;();</div>
<div class="line">    std::stringstream formula_stream(formula_str);</div>
<div class="line">    driver-&gt;parse(formula_stream);</div>
<div class="line">    whitemech::lydia::ltlf_ptr formula = driver-&gt;get_result();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// initialize the variables</span></div>
<div class="line">    <a class="code" href="classSyft_1_1InputOutputPartition.html">Syft::InputOutputPartition</a> partition = <a class="code" href="classSyft_1_1InputOutputPartition.html#a977c76841cb9c3aa7fe8a281993031d9">Syft::InputOutputPartition::construct_from_input</a>(input_vars, output_vars);</div>
<div class="line">    std::shared_ptr&lt;Syft::VarMgr&gt; var_mgr = std::make_shared&lt;Syft::VarMgr&gt;();</div>
<div class="line">    var_mgr-&gt;create_named_variables(partition.input_variables);</div>
<div class="line">    var_mgr-&gt;create_named_variables(partition.output_variables);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// build the explicit-state DFA</span></div>
<div class="line">    <a class="code" href="classSyft_1_1ExplicitStateDfa.html">Syft::ExplicitStateDfa</a> explicit_dfa = <a class="code" href="classSyft_1_1ExplicitStateDfa.html#aed0406d1f1d2dace3fc31bc288941969">Syft::ExplicitStateDfa::dfa_of_formula</a>(*formula);</div>
<div class="line">    <a class="code" href="classSyft_1_1ExplicitStateDfaAdd.html">Syft::ExplicitStateDfaAdd</a> explicit_dfa_add = <a class="code" href="classSyft_1_1ExplicitStateDfaAdd.html#af4ec91852395c954072e3187d3232f77">Syft::ExplicitStateDfaAdd::from_dfa_mona</a>(var_mgr, explicit_dfa);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// build the symbolic-state DFA from the explicit-state DFA</span></div>
<div class="line">    <a class="code" href="classSyft_1_1SymbolicStateDfa.html">Syft::SymbolicStateDfa</a> symbolic_dfa = <a class="code" href="classSyft_1_1SymbolicStateDfa.html#ac14b97fb14b1c3b97a3a9c7ffe4c76c8">Syft::SymbolicStateDfa::from_explicit</a>(</div>
<div class="line">            std::move(explicit_dfa_add));</div>
<div class="line">    </div>
<div class="line">    </div>
<div class="line">    <span class="comment">// do synthesis</span></div>
<div class="line">    var_mgr-&gt;partition_variables(partition.input_variables, partition.output_variables);</div>
<div class="line">    Syft::Player starting_player = Syft::Player::Agent;</div>
<div class="line">    Syft::Player protagonist_player = Syft::Player::Agent;</div>
<div class="line">    <a class="code" href="classSyft_1_1LTLfSynthesizer.html">Syft::LTLfSynthesizer</a> synthesizer(symbolic_dfa, starting_player,</div>
<div class="line">                                        protagonist_player, symbolic_dfa.<a class="code" href="classSyft_1_1SymbolicStateDfa.html#a3805aee1a5f0cc11f6598460646e29e1">final_states</a>(),</div>
<div class="line">                                        var_mgr-&gt;cudd_mgr()-&gt;bddOne());</div>
<div class="line">    <a class="code" href="structSyft_1_1SynthesisResult.html">Syft::SynthesisResult</a> result = synthesizer.run();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// expected: REALIZABLE</span></div>
<div class="line">    std::cout &lt;&lt; (result.realizability? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;NOT &quot;</span>) &lt;&lt; <span class="stringliteral">&quot;REALIZABLE&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassSyft_1_1ExplicitStateDfaAdd_html"><div class="ttname"><a href="classSyft_1_1ExplicitStateDfaAdd.html">Syft::ExplicitStateDfaAdd</a></div><div class="ttdoc">A DFA with explicit states and symbolic transitions represented in ADDs.</div><div class="ttdef"><b>Definition:</b> ExplicitStateDfaAdd.h:18</div></div>
<div class="ttc" id="aclassSyft_1_1ExplicitStateDfaAdd_html_af4ec91852395c954072e3187d3232f77"><div class="ttname"><a href="classSyft_1_1ExplicitStateDfaAdd.html#af4ec91852395c954072e3187d3232f77">Syft::ExplicitStateDfaAdd::from_dfa_mona</a></div><div class="ttdeci">static ExplicitStateDfaAdd from_dfa_mona(std::shared_ptr&lt; VarMgr &gt; var_mgr, const ExplicitStateDfa &amp;explicit_dfa)</div><div class="ttdoc">Constructs an explicit-state DFA in ADD representation from an explicit-state DFA.</div><div class="ttdef"><b>Definition:</b> ExplicitStateDfaAdd.cpp:44</div></div>
<div class="ttc" id="aclassSyft_1_1ExplicitStateDfa_html"><div class="ttname"><a href="classSyft_1_1ExplicitStateDfa.html">Syft::ExplicitStateDfa</a></div><div class="ttdoc">A DFA with explicit states and symbolic transitions.</div><div class="ttdef"><b>Definition:</b> ExplicitStateDfa.h:22</div></div>
<div class="ttc" id="aclassSyft_1_1ExplicitStateDfa_html_aed0406d1f1d2dace3fc31bc288941969"><div class="ttname"><a href="classSyft_1_1ExplicitStateDfa.html#aed0406d1f1d2dace3fc31bc288941969">Syft::ExplicitStateDfa::dfa_of_formula</a></div><div class="ttdeci">static ExplicitStateDfa dfa_of_formula(const whitemech::lydia::LTLfFormula &amp;formula)</div><div class="ttdoc">Construct an explicit-state DFA from a given formula using Lydia.</div><div class="ttdef"><b>Definition:</b> ExplicitStateDfa.cpp:31</div></div>
<div class="ttc" id="aclassSyft_1_1InputOutputPartition_html"><div class="ttname"><a href="classSyft_1_1InputOutputPartition.html">Syft::InputOutputPartition</a></div><div class="ttdoc">A partition of variables into input and output variables.</div><div class="ttdef"><b>Definition:</b> InputOutputPartition.h:12</div></div>
<div class="ttc" id="aclassSyft_1_1InputOutputPartition_html_a977c76841cb9c3aa7fe8a281993031d9"><div class="ttname"><a href="classSyft_1_1InputOutputPartition.html#a977c76841cb9c3aa7fe8a281993031d9">Syft::InputOutputPartition::construct_from_input</a></div><div class="ttdeci">static InputOutputPartition construct_from_input(const std::vector&lt; std::string &gt; inputs_substr, std::vector&lt; std::string &gt; outputs_substr)</div><div class="ttdoc">Constructs a partition from inputs.</div><div class="ttdef"><b>Definition:</b> InputOutputPartition.cpp:56</div></div>
<div class="ttc" id="aclassSyft_1_1LTLfSynthesizer_html"><div class="ttname"><a href="classSyft_1_1LTLfSynthesizer.html">Syft::LTLfSynthesizer</a></div><div class="ttdoc">A single-strategy-synthesizer for an LTLf formula given as a symbolic-state DFA.</div><div class="ttdef"><b>Definition:</b> LTLfSynthesizer.h:15</div></div>
<div class="ttc" id="aclassSyft_1_1SymbolicStateDfa_html"><div class="ttname"><a href="classSyft_1_1SymbolicStateDfa.html">Syft::SymbolicStateDfa</a></div><div class="ttdoc">A DFA with symbolic states and transitions.</div><div class="ttdef"><b>Definition:</b> SymbolicStateDfa.h:18</div></div>
<div class="ttc" id="aclassSyft_1_1SymbolicStateDfa_html_a3805aee1a5f0cc11f6598460646e29e1"><div class="ttname"><a href="classSyft_1_1SymbolicStateDfa.html#a3805aee1a5f0cc11f6598460646e29e1">Syft::SymbolicStateDfa::final_states</a></div><div class="ttdeci">CUDD::BDD final_states() const</div><div class="ttdoc">Returns the BDD encoding the set of final states.</div><div class="ttdef"><b>Definition:</b> SymbolicStateDfa.cpp:135</div></div>
<div class="ttc" id="aclassSyft_1_1SymbolicStateDfa_html_ac14b97fb14b1c3b97a3a9c7ffe4c76c8"><div class="ttname"><a href="classSyft_1_1SymbolicStateDfa.html#ac14b97fb14b1c3b97a3a9c7ffe4c76c8">Syft::SymbolicStateDfa::from_explicit</a></div><div class="ttdeci">static SymbolicStateDfa from_explicit(const ExplicitStateDfaAdd &amp;explicit_dfa)</div><div class="ttdoc">Converts an explicit DFA to a symbolic representation.</div><div class="ttdef"><b>Definition:</b> SymbolicStateDfa.cpp:92</div></div>
<div class="ttc" id="astructSyft_1_1SynthesisResult_html"><div class="ttname"><a href="structSyft_1_1SynthesisResult.html">Syft::SynthesisResult</a></div><div class="ttdef"><b>Definition:</b> Synthesizer.h:16</div></div>
</div><!-- fragment --><p>The expected output of the program is:</p>
<div class="fragment"><div class="line">REALIZABLE</div>
</div><!-- fragment --><p>Below we break down each step of the program. The first step is to define the <em>LTLf formula</em>, the set of <em>controllable</em> (or <em>output</em>) <em>variables</em>, and the set of <em>uncontrollable</em> (or <em>input</em>) <em>variables</em>:</p>
<div class="fragment"><div class="line">std::string formula_str = <span class="stringliteral">&quot;F(a | b)&quot;</span>;</div>
<div class="line">std::vector&lt;std::string&gt; input_vars{<span class="stringliteral">&quot;a&quot;</span>};</div>
<div class="line">std::vector&lt;std::string&gt; output_vars{<span class="stringliteral">&quot;b&quot;</span>};</div>
</div><!-- fragment --><p>Next, we need to parse the formula string and build the syntax tree of the formula. To do so, we rely on Lydia library that provides a parser for LTLf formulas. In particular, we instantiate the parser <code>whitemech::lydia::parsers::ltlf::LTLfDriver</code>, which can be found in the header <code>&lt;lydia/parser/ltlf/driver.hpp&gt;</code>.</p>
<div class="fragment"><div class="line"><span class="comment">// parse the formula</span></div>
<div class="line"><span class="keyword">auto</span> driver = std::make_shared&lt;whitemech::lydia::parsers::ltlf::LTLfDriver&gt;();</div>
<div class="line">std::stringstream formula_stream(formula_str);</div>
<div class="line">driver-&gt;parse(formula_stream);</div>
<div class="line">whitemech::lydia::ltlf_ptr formula = driver-&gt;get_result();</div>
</div><!-- fragment --><p>We also instantiate a <em>variable manager</em>, i.e. an instance of the class <code><a class="el" href="classSyft_1_1VarMgr.html" title="A dictionary that maps variable names to indices and vice versa.">Syft::VarMgr</a></code>. The definition of such class can be found in the header file <code><a class="el" href="VarMgr_8h_source.html">VarMgr.h</a></code>. Essentially, <code><a class="el" href="classSyft_1_1VarMgr.html" title="A dictionary that maps variable names to indices and vice versa.">Syft::VarMgr</a></code> is a wrapper of the CUDD BDD manager, and provides auxiliary fields and methods specific for LTLf synthesis. The class <code><a class="el" href="classSyft_1_1InputOutputPartition.html" title="A partition of variables into input and output variables.">Syft::InputOutputPartition</a></code> is simply a container class for the input and output variables, and can be found in the header file <code><a class="el" href="InputOutputPartition_8h_source.html">game/InputOutputPartition.h</a></code>.</p>
<div class="fragment"><div class="line"><span class="comment">// initialize the variables</span></div>
<div class="line"><a class="code" href="classSyft_1_1InputOutputPartition.html">Syft::InputOutputPartition</a> partition = <a class="code" href="classSyft_1_1InputOutputPartition.html#a977c76841cb9c3aa7fe8a281993031d9">Syft::InputOutputPartition::construct_from_input</a>(input_vars, output_vars);</div>
<div class="line">std::shared_ptr&lt;Syft::VarMgr&gt; var_mgr = std::make_shared&lt;Syft::VarMgr&gt;();</div>
<div class="line">var_mgr-&gt;create_named_variables(partition.input_variables);</div>
<div class="line">var_mgr-&gt;create_named_variables(partition.output_variables);</div>
</div><!-- fragment --><p>Before calling the LTLf synthesis procedure, we have to build the DFA of the input LTLf formula. To do so, we rely on the static function <code><a class="el" href="classSyft_1_1ExplicitStateDfa.html#aed0406d1f1d2dace3fc31bc288941969" title="Construct an explicit-state DFA from a given formula using Lydia.">Syft::ExplicitStateDfa::dfa_of_formula()</a></code>, which can be found in the header file <code><a class="el" href="ExplicitStateDfa_8h_source.html">automata/ExplicitStateDfa.h</a></code>:</p>
<div class="fragment"><div class="line"><span class="comment">// build the explicit-state DFA</span></div>
<div class="line"><a class="code" href="classSyft_1_1ExplicitStateDfa.html">Syft::ExplicitStateDfa</a> explicit_dfa = <a class="code" href="classSyft_1_1ExplicitStateDfa.html#aed0406d1f1d2dace3fc31bc288941969">Syft::ExplicitStateDfa::dfa_of_formula</a>(*formula);</div>
</div><!-- fragment --><p>The output of the Lydia tool is a MONA DFA (see the <a href="https://www.brics.dk/mona/mona14.pdf">MONA manual</a> for more information). To proceed, we require to translate the MONA DFA into a DFA based on Algebraic Decision Diagrams (ADD), i.e. a DFA with explicit states (as the MONA DFA), but with the symbolic transitions represented in ADDs (instead of Shared Multi-terminal BDDs). The class that implements this DFA representation is <code>ExplicitStateDfaAdd</code>, and the function <code><a class="el" href="classSyft_1_1ExplicitStateDfaAdd.html#af4ec91852395c954072e3187d3232f77" title="Constructs an explicit-state DFA in ADD representation from an explicit-state DFA.">Syft::ExplicitStateDfaAdd::from_dfa_mona</a></code> performs such construction. The declaration of the class <code><a class="el" href="classSyft_1_1ExplicitStateDfaAdd.html" title="A DFA with explicit states and symbolic transitions represented in ADDs.">Syft::ExplicitStateDfaAdd</a></code> can be found in the header file <code><a class="el" href="ExplicitStateDfaAdd_8h_source.html">automata/ExplicitStateDfaAdd.h</a></code>:</p>
<div class="fragment"><div class="line"><a class="code" href="classSyft_1_1ExplicitStateDfaAdd.html">Syft::ExplicitStateDfaAdd</a> explicit_dfa_add = <a class="code" href="classSyft_1_1ExplicitStateDfaAdd.html#af4ec91852395c954072e3187d3232f77">Syft::ExplicitStateDfaAdd::from_dfa_mona</a>(var_mgr, explicit_dfa);</div>
</div><!-- fragment --><p>LydiaSyft requires the DFA to be _(fully) symbolic_, i.e. with symbolic states and transitions. The class that implements the symbolic DFA representation is <code>SymbolicStateDfa</code>. To build a <code>SymbolicStateDfa</code> from an <code>ExplicitStateDfaAdd</code>, we use the function <code><a class="el" href="classSyft_1_1SymbolicStateDfa.html#ac14b97fb14b1c3b97a3a9c7ffe4c76c8" title="Converts an explicit DFA to a symbolic representation.">Syft::SymbolicStateDfa::from_explicit</a></code>. The declaration of the class <code><a class="el" href="classSyft_1_1SymbolicStateDfa.html" title="A DFA with symbolic states and transitions.">Syft::SymbolicStateDfa</a></code> can be found in the header file <code><a class="el" href="SymbolicStateDfa_8h_source.html">automata/SymbolicStateDfa.h</a></code>:</p>
<div class="fragment"><div class="line"><a class="code" href="classSyft_1_1SymbolicStateDfa.html">Syft::SymbolicStateDfa</a> symbolic_dfa = <a class="code" href="classSyft_1_1SymbolicStateDfa.html#ac14b97fb14b1c3b97a3a9c7ffe4c76c8">Syft::SymbolicStateDfa::from_explicit</a>(std::move(explicit_dfa_add));</div>
</div><!-- fragment --><p>Finally, we are ready to perform the synthesis step. First, we setup the variable manager to partition the variables in the input and output sets:</p>
<div class="fragment"><div class="line">var_mgr-&gt;partition_variables(partition.input_variables, partition.output_variables);</div>
</div><!-- fragment --><p>Then, we create an instance of <code><a class="el" href="classSyft_1_1LTLfSynthesizer.html" title="A single-strategy-synthesizer for an LTLf formula given as a symbolic-state DFA.">Syft::LTLfSynthesizer</a></code> (found in <code><a class="el" href="LTLfSynthesizer_8h_source.html">synthesizer/LTLfSynthesizer.h</a></code>), a functor class that wraps the initialization and the execution of the synthesis procedure.</p>
<div class="fragment"><div class="line">Syft::Player starting_player = Syft::Player::Agent;</div>
<div class="line">Syft::Player protagonist_player = Syft::Player::Agent;</div>
<div class="line"><a class="code" href="classSyft_1_1LTLfSynthesizer.html">Syft::LTLfSynthesizer</a> synthesizer(symbolic_dfa, starting_player,</div>
<div class="line">                                    protagonist_player, symbolic_dfa.<a class="code" href="classSyft_1_1SymbolicStateDfa.html#a3805aee1a5f0cc11f6598460646e29e1">final_states</a>(),</div>
<div class="line">                                    var_mgr-&gt;cudd_mgr()-&gt;bddOne());</div>
</div><!-- fragment --><p>The constructor of <code><a class="el" href="classSyft_1_1LTLfSynthesizer.html" title="A single-strategy-synthesizer for an LTLf formula given as a symbolic-state DFA.">Syft::LTLfSynthesizer</a></code> takes the following parameters:</p>
<ul>
<li><code>spec</code>: A symbolic-state DFA representing the LTLf formula.</li>
<li><code>starting_player</code>: The player that moves first each turn.</li>
<li><code>protagonist_player</code>: The player for which we aim to find the winning strategy.</li>
<li><code>goal_states</code>: The set of states that the agent must reach to win.</li>
<li><code>state_space</code>: The state space.</li>
</ul>
<p>In our case, we have that the player <code>Agent</code> is both the starting player and the protagonist agent. The goal states are the final states of the DFA, and the states space is the entire DFA (hence we use the CUDD expression for "true": <code>var_mgr-&gt;cudd_mgr()-&gt;bddOne()</code>).</p>
<p>To run the synthesis procedure, we use:</p>
<div class="fragment"><div class="line">Syft::SynthesisResult result = synthesizer.run();</div>
</div><!-- fragment --><p>The <code><a class="el" href="structSyft_1_1SynthesisResult.html">Syft::SynthesisResult</a></code> object contains all the details of the solution found, if any:</p>
<div class="fragment"><div class="line">struct SynthesisResult {</div>
<div class="line">    bool realizability;</div>
<div class="line">    CUDD::BDD winning_states;</div>
<div class="line">    CUDD::BDD winning_moves;</div>
<div class="line">    std::unique_ptr&lt;Transducer&gt; transducer;</div>
<div class="line">    CUDD::BDD safe_states;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The field <code>realizability</code> is set to <code>true</code> if a solution is found, <code>false</code> otherwise. Then, if <code>realizability</code> is <code>true</code>:</p>
<ul>
<li><code>winning_states</code> is a BDD representing the set of states that are winning;</li>
<li><code>winning_moves</code> is a BDD representing the set of winning moves;</li>
<li><code>transducer</code> is an instance of the class <code>Transducer</code>, which represents the winning strategy;</li>
<li><code>safe_states</code> is set only in case of <code>GR(1)</code> synthesis (we can ignore it now). </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="md_docs_p00_api.html">C++ API</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
